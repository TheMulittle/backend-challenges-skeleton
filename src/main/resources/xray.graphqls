type Query {
	getFolder(projectId: String, testPlanId: String, path: String!): FolderResults
	getTest(issueId: String): Test
	getTests(jql: String, issueIds: [String], projectId: String, testType: TestTypeInput, modifiedSince: String, limit: Int!, start: Int, folder: FolderSearchInput): TestResults 
	getExpandedTest(issueId: String): ExpandedTest 
	getExpandedTests(jql: String, issueIds: [String], projectId: String, testType: TestTypeInput, modifiedSince: String, limit: Int!, start: Int, folder: FolderSearchInput): ExpandedTestResults 
	getPrecondition(issueId: String): Precondition 
	getPreconditions(
	jql: String,
	issueIds: [String],
	projectId: String,
	preconditionType: TestTypeInput,
	limit: Int!,
	start: Int,
	modifiedSince: String,
	folder: PreconditionFolderSearchInput
	): PreconditionResults 
	getTestSet(issueId: String): TestSet 
	getTestSets(jql: String, issueIds: [String], projectId: String, limit: Int!, start: Int, modifiedSince: String): TestSetResults 
	getTestPlan(issueId: String): TestPlan 
	getTestPlans(jql: String, issueIds: [String], projectId: String, limit: Int!, start: Int, modifiedSince: String): TestPlanResults 
	getTestExecution(issueId: String): TestExecution 
	getTestExecutions(jql: String, issueIds: [String], projectId: String, limit: Int!, start: Int, modifiedSince: String): TestExecutionResults 
	getTestRun(testIssueId: String, testExecIssueId: String): TestRun 
	getTestRunById(id: String): TestRun 
	getTestRuns(testIssueIds: [String], testExecIssueIds: [String], testRunAssignees: [String], limit: Int!, start: Int, modifiedSince: String): TestRunResults 
	getTestRunsById(ids: [String], limit: Int!, start: Int): TestRunResults 
	getStepStatus(name: String): StepStatus 
	getStatus(name: String): Status 
	getStatuses: [Status]
	getStepStatuses: [StepStatus] 
	getProjectSettings(projectIdOrKey: String): ProjectSettings 
	getIssueLinkTypes: [IssueLinkType] 
}

type Mutation {
  createFolder(projectId: String, testPlanId: String, path: String!, testIssueIds: [String], issueIds: [String]): ActionFolderResult 
  deleteFolder(projectId: String, testPlanId: String, path: String!): String 
  renameFolder(projectId: String, testPlanId: String, path: String!, newName: String!): ActionFolderResult 
  moveFolder(projectId: String, testPlanId: String, path: String!, destinationPath: String!, index: Int): ActionFolderResult 
  addTestsToFolder(projectId: String, testPlanId: String, path: String!, testIssueIds: [String]!, index: Int): ActionFolderResult 
  addIssuesToFolder(projectId: String!, path: String!, issueIds: [String]!, index: Int): ActionFolderResult 
  removeTestsFromFolder(projectId: String, testPlanId: String, testIssueIds: [String]!): String 
  removeIssuesFromFolder(projectId: String!, issueIds: [String]!): String 
  createTest(testType: UpdateTestTypeInput, steps: [CreateStepInput], unstructured: String, gherkin: String, preconditionIssueIds: [String], folderPath: String, jira: JSON!): CreateTestResult 
  updateTestType(issueId: String!, testType: UpdateTestTypeInput!): Test 
  updateUnstructuredTestDefinition(issueId: String!, unstructured: String!): Test 
  updateGherkinTestDefinition(issueId: String!, gherkin: String!): Test 
  deleteTest(issueId: String!): String 
  addTestStep(issueId: String!, step: CreateStepInput!): Step 
  updateTestStep(stepId: String!, step: UpdateStepInput!): UpdateTestStepResult 
  removeTestStep(stepId: String!): String 
  removeAllTestSteps(issueId: String!): String 
  addPreconditionsToTest(issueId: String!, preconditionIssueIds: [String]!): AddPreconditionsResult 
  removePreconditionsFromTest(issueId: String!, preconditionIssueIds: [String]!): String 
  updateTestFolder(issueId: String!, folderPath: String!): String 
  updatePreconditionFolder(issueId: String!, folderPath: String!): String 
  addTestPlansToTest(issueId: String!, testPlanIssueIds: [String]!): AddTestPlansResult 
  removeTestPlansFromTest(issueId: String!, testPlanIssueIds: [String]!): String 
  addTestExecutionsToTest(issueId: String!, testExecIssueIds: [String]!): AddTestExecutionsResult 
  removeTestExecutionsFromTest(issueId: String!, testExecIssueIds: [String]!): String 
  createPrecondition(preconditionType: UpdatePreconditionTypeInput, definition: String, testIssueIds: [String], folderPath: String, jira: JSON!): CreatePreconditionResult 
  updatePrecondition(issueId: String!, data: UpdatePreconditionInput): Precondition 
  deletePrecondition(issueId: String!): String 
  addTestsToPrecondition(issueId: String!, testIssueIds: [String]!): AddTestsResult 
  removeTestsFromPrecondition(issueId: String!, testIssueIds: [String]!): String 
  createTestSet(testIssueIds: [String], jira: JSON!): CreateTestSetResult 
  deleteTestSet(issueId: String!): String 
  addTestsToTestSet(issueId: String!, testIssueIds: [String]!): AddTestsResult 
  removeTestsFromTestSet(issueId: String!, testIssueIds: [String]!): String 
  createTestPlan(testIssueIds: [String], jira: JSON!): CreateTestPlanResult 
  deleteTestPlan(issueId: String!): String 
  addTestsToTestPlan(issueId: String!, testIssueIds: [String]!): AddTestsResult 
  removeTestsFromTestPlan(issueId: String!, testIssueIds: [String]!): String 
  addTestExecutionsToTestPlan(issueId: String!, testExecIssueIds: [String]!): AddTestExecutionsResult 
  removeTestExecutionsFromTestPlan(issueId: String!, testExecIssueIds: [String]!): String 
  createTestExecution(testIssueIds: [String], testEnvironments: [String], jira: JSON!): CreateTestExecutionResult 
  deleteTestExecution(issueId: String!): String 
  addTestsToTestExecution(issueId: String!, testIssueIds: [String]!): AddTestsResult 
  removeTestsFromTestExecution(issueId: String!, testIssueIds: [String]!): String 
  addTestEnvironmentsToTestExecution(issueId: String!, testEnvironments: [String]!): AddTestEnvironmentsResult 
  removeTestEnvironmentsFromTestExecution(issueId: String!, testEnvironments: [String]!): String 
  resetTestRun(id: String!): String 
  updateTestRunStatus(id: String!, status: String!): String 
  updateTestRunComment(id: String!, comment: String!): String 
  updateTestRun(id: String!, comment: String, startedOn: String, finishedOn: String, assigneeId: String, executedById: String, customFields: [CustomFieldInput]): UpdateTestRunResult 
  addDefectsToTestRun(id: String!, issues: [String]!): AddDefectsResult 
  removeDefectsFromTestRun(id: String!, issues: [String]!): String 
  addEvidenceToTestRun(id: String!, evidence: [AttachmentDataInput]!): AddEvidenceResult 
  removeEvidenceFromTestRun(id: String!, evidenceIds: [String], evidenceFilenames: [String]): RemoveEvidenceResult 
  updateTestRunStep(testRunId: String!, stepId: String!, updateData: UpdateTestRunStepInput!, iterationRank: String): UpdateTestRunStepResult 
  addEvidenceToTestRunStep(testRunId: String!, stepId: String!, evidence: [AttachmentDataInput], iterationRank: String): AddEvidenceResult 
  removeEvidenceFromTestRunStep(testRunId: String!, stepId: String!, iterationRank: String, evidenceIds: [String], evidenceFilenames: [String]): RemoveEvidenceResult 
  addDefectsToTestRunStep(testRunId: String!, stepId: String!, issues: [String], iterationRank: String): AddDefectsResult 
  removeDefectsFromTestRunStep(testRunId: String!, stepId: String!, issues: [String]!, iterationRank: String): RemoveDefectsResult 
  updateTestRunStepComment(testRunId: String!, stepId: String!, comment: String!, iterationRank: String): String 
  updateTestRunStepStatus(testRunId: String!, stepId: String!, status: String!, iterationRank: String): UpdateTestRunStepStatusResult 
  updateTestRunExampleStatus(exampleId: String!, status: String!): UpdateTestRunExampleStatusResult 
  updateIterationStatus(testRunId: String!, iterationRank: String!, status: String!): UpdateIterationStatusResult 
  setTestRunTimer(testRunId: String!, running: Boolean, reset: Boolean): String 
}
 

 	type ActionFolderResult {
 	
 	# Folder updated during the operation.
 	folder: SimpleFolderResults
 	
 	# Warning generated during the operation.
 	warnings: [String]
 	
 	}

 	type AddDefectsResult {
 	
 	# Ids of the added Defects.
 	addedDefects: [String]
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

type AddEvidenceResult {
 	
 	# Ids of the added Evidence.
 	addedEvidence: [String]
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

 	type AddPreconditionsResult {
 	
 	# Issue ids of the added Preconditions.
 	addedPreconditions: [String]
 	
 	# Warning generated during the operation.
 	warning: String
 	
 	}

type AddTestEnvironmentsResult {
 	
 	# Test Environments that were associated.
 	associatedTestEnvironments: [String]
 	
 	# Test Environments that were created.
 	createdTestEnvironments: [String]
 	
 	# Warning generated during the operation.
 	warning: String
 	
 	}

	type AddTestExecutionsResult {
 	
 	# Issue ids of the added Test Executions.
 	addedTestExecutions: [String]
 	
 	# Warning generated during the operation.
 	warning: String
 	
 	}

	type AddTestPlansResult {
 	
 	# Issue ids of the added Test Plans.
 	addedTestPlans: [String]
 	
 	# Warning generated during the operation.
 	warning: String
 	
 	}

type AddTestSetsResult {
 	
 	# Issue ids of the added Test Set.
 	addedTestSets: [String]
 	
 	# Warning generated during the operation.
 	warning: String
 	
 	}

type AddTestsResult {
 	
 	# Issue Ids of the added Tests.
 	addedTests: [String]
 	
 	# Warning generated during the operation.
 	warning: String
 	
 	}

type Attachment {
 	
 	# Id of the attachment.
 	id: String
 	
 	# Filename of the attachment.
 	filename: String
 	
 	# If the file is stored in Jira.
 	storedInJira: Boolean
 	
 	# Download link of the attachment.
 	downloadLink: String
 	
 	}

	type CreatePreconditionResult {
 	
 	# Precondition that was created.
 	precondition: Precondition
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

type CreateTestExecutionResult {
 	
 	# Test Execution that was created.
 	testExecution: TestExecution
 	
 	# Test Environments that were created.
 	createdTestEnvironments: [String]
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

 	type CreateTestPlanResult {
 	
 	# Test Plan that was created.
 	testPlan: TestPlan
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

type CreateTestResult {
 	
 	# Test that was created.
 	test: Test
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

	type CreateTestSetResult {
 	
 	# Test Set that was created.
 	testSet: TestSet
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

 	type CustomStepField {
 	
 	# Id of the Custom Field.
 	id: String
 	
 	# Name of the Custom Field.
 	name: String
 	
 	# Value of the Custom Field.
 	value: JSON
 	
 	}

type Evidence {
 	
 	# Id of the Evidence.
 	id: String
 	
 	# Filename of the Evidence.
 	filename: String
 	
 	# If file is stored in Jira
 	storedInJira: Boolean
 	
 	# Download link of the Evidence.
 	downloadLink: String
 	
 	# File size in bytes.
 	size: Int
 	
 	# Evidence creation timestamp.
 	createdOn: String
 	
 	}

 	type Example {
 	
 	# Id of the Example.
 	id: String
 	
 	# Status of the Example.
 	status: StepStatus
 	
 	# Duration of the Example.
 	duration: Float
 	
 	}

type ExpandedStep {
 	
 	# Id of the Step.
 	id: String
 	
 	# Action of the Step.
 	action: String
 	
 	# Data of the Step.
 	data: String
 	
 	# Result of the Step.
 	result: String
 	
 	# Attachments of the Step.
 	attachments: [Attachment]
 	
 	# Custom Fields of the Step.
 	customFields: [CustomStepField]
 	
 	# The issue id of the called test with the step
 	calledTestIssueId: String
 	
 	# The issue id of the test calling the step
 	parentTestIssueId: String
 	
 	}

type ExpandedTest {
 	
 	# Issue id of the Test issue.
 	issueId: String
 	
 	# Project id of the Test issue.
 	projectId: String
 	
 	# Test type of the Test issue.
 	testType: TestType
 	
 	# Unstructured definition of the Test issue.
 	unstructured: String
 	
 	# Gherkin definition of the Test issue.
 	gherkin: String
 	
 	# Test Repository folder of the Test.
 	folder: Folder
 	
 	# Gherkin type of the Test issue.
 	# Possible values: 'scenario' or 'scenario_outline'.
 	scenarioType: String
 	
 	# List of Precondition associated with the Test issue.
 	#
 	# Arguments
 	# issueIds: the ids of the Preconditions.
 	# limit: the maximum amount of Preconditions to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	preconditions(issueIds: [String], limit: Int!, start: Int): PreconditionResults
 	
 	# List of Test Sets associated with the Test issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Test Sets
 	# limit: the maximum amount of Test Sets to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testSets(issueIds: [String], limit: Int!, start: Int): TestSetResults
 	
 	# List of Test Plans associated with the Test issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Test Plans
 	# limit: the maximum amount of Test Plans to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testPlans(issueIds: [String], limit: Int!, start: Int): TestPlanResults
 	
 	# List of Test Executions associated with the Test issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Test Executions
 	# limit: the maximum amount of Test Executions to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testExecutions(issueIds: [String], limit: Int!, start: Int): TestExecutionResults
 	
 	# List of Test Runs for the Test issue
 	#
 	# Arguments
 	# limit: the maximum amount of Test Runs to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testRuns(limit: Int!, start: Int): TestRunResults
 	
 	# Extra Jira information of the Test issue.
 	#
 	# Arguments
 	# fields: List of the fields to be displayed.
 	# Check the field 'fields' of this Jira endpoint for more information.
 	jira(fields: [String]): JSON!
 	
 	# Status of the Test. This status can be calculated based on latest status, version or Test Plan.
 	#
 	# Arguments
 	# environment: the environment for which to calculate the for status.
 	# isFinal: whether the final statuses has precedence over non-final.
 	# version: the version name for which to calculate the status for.
 	# testPlan: the Test Plan id for which to calculate the status for.
 	status(environment: String, isFinal: Boolean, version: String, testPlan: String): TestStatusType
 	
 	# Date when the test was last modified.
 	lastModified: String
 	
 	# Expanded step definition of the test.
 	steps: [ExpandedStep]
 	
 	# Warnings generated while expanding the test steps.
 	warnings: [String]
 	
 	}

type ExpandedTestResults {
 	
 	# Total amount of issues.
 	total: Int
 	
 	# The index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# The maximum amount of Tests to be returned. The maximum is 100.
 	limit: Int
 	
 	# Expanded test issue results.
 	results: [ExpandedTest]
 	
 	}

 	type Folder {
 	
 	# Folder name
 	name: String
 	
 	# Folder path
 	path: String
 	
 	}

type FolderResults {
 	
 	# Folder name
 	name: String
 	
 	# Folder path
 	path: String
 	
 	# Folder issues count
 	issuesCount: Int
 	
 	# Folder tests count
 	testsCount: Int
 	
 	# Folder preconditions count
 	preconditionsCount: Int
 	
 	# Folder children
 	folders: JSON
 	
 	}

type IssueLinkType {
 	
 	# Name of Issue Link Type
 	name: String
 	
 	# Id of Issue Link Type
 	id: String
 	
 	}

	type Precondition {
 	
 	# Id of the Precondition issue.
 	issueId: String
 	
 	# Project id of the Precondition issue.
 	projectId: String
 	
 	# Precondition Type of the Precondition issue.
 	preconditionType: TestType
 	
 	# Definition of the Precondition issue.
 	definition: String
 	
 	# List of the Tests associated with the Precondition issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Tests.
 	# limit: the maximum amount of Tests to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	tests(issueIds: [String], limit: Int!, start: Int): TestResults
 	
 	# Extra Jira information of the Precondition Issue.
 	#
 	# Arguments
 	# fields: list of the fields to be displayed.
 	# Check the field 'fields' of this Jira endpoint for more information.
 	jira(fields: [String]): JSON
 	
 	# Date when the precondition was last modified.
 	lastModified: String
 	
 	# Test Repository folder of the Precondition.
 	folder: Folder
 	
 	}

type PreconditionResults {
 	
 	# Total amount of issues.
 	total: Int
 	
 	# Index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# Maximum amount of Preconditions to be returned. The maximum is 100.
 	limit: Int
 	
 	# Precondition issue results.
 	results: [Precondition]
 	
 	}

type ProjectSettings {
 	
 	# Project id.
 	projectId: String
 	
 	# Test Environments.
 	testEnvironments: [String]
 	
 	# Test Coverage Settings.
 	testCoverageSettings: ProjectSettingsTestCoverage
 	
 	# Defect Issue Types.
 	defectIssueTypes: [String]
 	
 	# Test Type Settings.
 	testTypeSettings: ProjectSettingsTestType
 	
 	# Test Step Settings.
 	testStepSettings: ProjectSettingsTestStepSettings
 	
 	# Test Run Custom Fields Settings.
 	testRunCustomFieldSettings: ProjectSettingsTestRunCustomFields
 	
 	}

type ProjectSettingsTestCoverage {
 	
 	# Coverable issue type ids
 	coverableIssueTypeIds: [String]
 	
 	# Epic - Issues(Stories) relation
 	epicIssuesRelation: Boolean
 	
 	# Issue - Sub-tasks relation
 	issueSubTasksRelation: Boolean
 	
 	# Issue Link Type Id
 	issueLinkTypeId: String
 	
 	# Issue Link Type Direction
 	issueLinkTypeDirection: String
 	
 	}

type ProjectSettingsTestRunCustomField {
 	
 	# Id
 	id: String
 	
 	# Name
 	name: String
 	
 	# Type
 	type: String
 	
 	# Is the field required
 	required: Boolean
 	
 	# Values
 	values: [String]
 	
 	}

	type ProjectSettingsTestRunCustomFields {
 	
 	# Fields
 	fields: [ProjectSettingsTestRunCustomField]
 	
 	}

type ProjectSettingsTestStepField {
 	
 	# Id
 	id: String
 	
 	# Name
 	name: String
 	
 	# Type
 	type: String
 	
 	# Is the field required
 	required: Boolean
 	
 	# Is the field disabled
 	disabled: Boolean
 	
 	# Values
 	values: [String]
 	
 	}

 	type ProjectSettingsTestStepSettings {
 	
 	# Fields
 	fields: [ProjectSettingsTestStepField]
 	
 	}

type ProjectSettingsTestType {
 	
 	# Test Types
 	testTypes: [TestType]
 	
 	# Default Test Type Id
 	defaultTestTypeId: String
 	
 	}

type RemoveDefectsResult {
 	
 	# Ids of the removed Defects.
 	removedDefects: [String]
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

	type RemoveEvidenceResult {
 	
 	# Ids of the removed Evidence.
 	removedEvidence: [String]
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

type Result {
 	
 	# Output if exist an error or a failure (JUNIT, XUNIT, NUNIT, TESTNG)
 	log: String
 	
 	# Examples of the Result.
 	examples: [ResultsExample]
 	
 	# Whether or not the Result was imported.
 	wasImported: String
 	
 	# Duration of the Result.
 	duration: Float
 	
 	# Status of the Result.
 	status: StepStatus
 	
 	# Name of the Result.
 	name: String
 	
 	# Hooks of the Results.
 	hooks: [ResultsStep]
 	
 	# Backgrounds of the Results.
 	backgrounds: [ResultsStep]
 	
 	# Steps of the Results.
 	steps: [ResultsStep]
 	
 	}

	type ResultsEmbedding {
 	
 	# Filename of the Embedding.
 	filename: String
 	
 	# Mime Type of the Embedding.
 	mimeType: String
 	
 	# Data of the Embedding. Base64 format.
 	data: String
 	
 	# Link to download the embedding if no data is present
 	downloadLink: String
 	
 	}

type ResultsExample {
 	
 	# Whether or not the Result was imported.
 	wasImported: String
 	
 	# Duration of the Result.
 	duration: Float
 	
 	# Status of the Result.
 	status: StepStatus
 	
 	# Hooks of the Results.
 	hooks: [ResultsStep]
 	
 	# Backgrounds of the Results.
 	backgrounds: [ResultsStep]
 	
 	# Steps of the Results.
 	steps: [ResultsStep]
 	
 	}

type ResultsStep {
 	
 	# If a gherkin step, keyword of the gherkin step.
 	keyword: String
 	
 	# Name of the step.
 	name: String
 	
 	# Embeddings of the step.
 	embeddings: [ResultsEmbedding]
 	
 	# Duration of the step.
 	duration: Float
 	
 	# Error of the step.
 	error: String
 	
 	# Status of the step.
 	status: StepStatus
 	
 	# If a Robot step, output of the Robot step.
 	log: String
 	
 	}

type SimpleFolderResults {
 	
 	# Folder name
 	name: String
 	
 	# Folder path
 	path: String
 	
 	# Folder tests count
 	testsCount: Int
 	
 	# Folder preconditions count
 	preconditionsCount: Int
 	
 	# Folder issues count
 	issuesCount: Int
 	
 	}

type Status {
 	
 	# Name of the Status.
 	name: String
 	
 	# Description of the Status.
 	description: String
 	
 	# Whether the Status is final or not.
 	final: Boolean
 	
 	# Color of the Status.
 	color: String
 	
 	# Coverage mapping of the Status.
 	coverageStatus: String
 	
 	}

 	type Step {
 	
 	# Id of the Step.
 	id: String
 	
 	# Action of the Step.
 	action: String
 	
 	# Data of the Step.
 	data: String
 	
 	# Result of the Step.
 	result: String
 	
 	# Attachments of the Step.
 	attachments: [Attachment]
 	
 	# Custom Fields of the Step.
 	customFields: [CustomStepField]
 	
 	# The issue id of the test being called in the step.
 	callTestIssueId: String
 	
 	}

type StepStatus {
 	
 	# Name of the Status.
 	name: String
 	
 	# Description of the Status.
 	description: String
 	
 	# Color of the Status.
 	color: String
 	
 	# The test status to which the step status is mapped to.
 	testStatus: Status
 	
 	}

type Test {
 	
 	# Issue id of the Test issue.
 	issueId: String
 	
 	# Project id of the Test issue.
 	projectId: String
 	
 	# Test type of the Test issue.
 	testType: TestType
 	
 	# Step definition of the Test issue.
 	steps: [Step]
 	
 	# Unstructured definition of the Test issue.
 	unstructured: String
 	
 	# Gherkin definition of the Test issue.
 	gherkin: String
 	
 	# Test Repository folder of the Test.
 	folder: Folder
 	
 	# Gherkin type of the Test issue.
 	# Possible values: 'scenario' or 'scenario_outline'.
 	scenarioType: String
 	
 	# List of Precondition associated with the Test issue.
 	#
 	# Arguments
 	# issueIds: the ids of the Preconditions.
 	# limit: the maximum amount of Preconditions to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	preconditions(issueIds: [String], limit: Int!, start: Int): PreconditionResults
 	
 	# List of Test Sets associated with the Test issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Test Sets
 	# limit: the maximum amount of Test Sets to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testSets(issueIds: [String], limit: Int!, start: Int): TestSetResults
 	
 	# List of Test Plans associated with the Test issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Test Plans
 	# limit: the maximum amount of Test Plans to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testPlans(issueIds: [String], limit: Int!, start: Int): TestPlanResults
 	
 	# List of Test Executions associated with the Test issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Test Executions
 	# limit: the maximum amount of Test Executions to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testExecutions(issueIds: [String], limit: Int!, start: Int): TestExecutionResults
 	
 	# List of Test Runs for the Test issue
 	#
 	# Arguments
 	# limit: the maximum amount of Test Runs to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testRuns(limit: Int!, start: Int): TestRunResults
 	
 	# Extra Jira information of the Test issue.
 	#
 	# Arguments
 	# fields: List of the fields to be displayed.
 	# Check the field 'fields' of this Jira endpoint for more information.
 	jira(fields: [String]): JSON!
 	
 	# Status of the Test. This status can be calculated based on latest status, version or Test Plan.
 	#
 	# Arguments
 	# environment: the environment for which to calculate the for status.
 	# isFinal: whether the final statuses has precedence over non-final.
 	# version: the version name for which to calculate the status for.
 	# testPlan: the Test Plan id for which to calculate the status for.
 	status(environment: String, isFinal: Boolean, version: String, testPlan: String): TestStatusType
 	
 	# Date when the test was last modified.
 	lastModified: String
 	
 	}

type TestExecution {
 	
 	# Id of the Test Execution issue.
 	issueId: String
 	
 	# Project id of the Test Execution issue.
 	projectId: String
 	
 	# Test Environments of the Test Execution.
 	testEnvironments: [String]
 	
 	# List of Tests associated with the Test Execution Issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Tests.
 	# limit: the maximum amount of tests to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	tests(issueIds: [String], limit: Int!, start: Int): TestResults
 	
 	# List of Test Plans associated with the Test Execution Issue.
 	#
 	# Arguments
 	# issueIds: Ids of the Test Plans.
 	# limit: the maximum amount of Test Plans to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testPlans(issueIds: [String], limit: Int!, start: Int): TestPlanResults
 	
 	# List of Test Runs for the Test Execution Issue.
 	#
 	# Arguments
 	# limit: the maximum amount of tests to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testRuns(limit: Int!, start: Int): TestRunResults
 	
 	# Extra Jira information of the Test Execution Issue.
 	#
 	# Arguments
 	# fields: List of the fields to be displayed.
 	# Check the field 'fields' of this Jira endpoint for more information.
 	jira(fields: [String]): JSON
 	
 	# Date when the test exec was last modified.
 	lastModified: String
 	
 	}

type TestExecutionResults {
 	
 	# Total amount of issues.
 	total: Int
 	
 	# Index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# Maximum amount of Test Executions to be returned. The maximum is 100.
 	limit: Int
 	
 	# Test Execution issue results.
 	results: [TestExecution]
 	
 	}

type TestPlan {
 	
 	# Id of the Test Plan issue.
 	issueId: String
 	
 	# Project id of the Test Plan issue.
 	projectId: String
 	
 	# List of Tests associated with the Test Plan issue.
 	#
 	# Arguments
 	# issueIds: the issue ids of the Tests.
 	# limit: the maximum amount of tests to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	tests(issueIds: [String], limit: Int!, start: Int): TestResults
 	
 	# List of Test Executions associated with the Test Plan issue.
 	#
 	# Arguments
 	# issueIds: issue ids of the Test Executions.
 	# limit: the maximum amount of tests to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	testExecutions(issueIds: [String], limit: Int!, start: Int): TestExecutionResults
 	
 	# Extra Jira information of the Test Plan issue.
 	#
 	# Arguments
 	# fields: list of the fields to be displayed.
 	# Check the field 'fields' of this Jira endpoint for more information.
 	jira(fields: [String]): JSON
 	
 	# Folder structure of the Test Plan.
 	folders: FolderResults
 	
 	# Date when the test plan was last modified.
 	lastModified: String
 	
 	}

 	type TestPlanResults {
 	
 	# Total amount of issues.
 	total: Int
 	
 	# Index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# Maximum amount of Test Plans to be returned. The maximum is 100.
 	limit: Int
 	
 	# Test Plan issue results.
 	results: [TestPlan]
 	
 	}

	type TestResults {
 	
 	# Total amount of issues.
 	total: Int
 	
 	# The index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# The maximum amount of Tests to be returned. The maximum is 100.
 	limit: Int
 	
 	# Test issue results.
 	results: [Test]
 	
 	}

type TestRun {
 	
 	# Id of the Test Run.
 	id: String
 	
 	# Status of the Test Run.
 	status: Status
 	
 	# Generic definition of the Test issue.
 	unstructured: String
 	
 	# Cucumber definition of the Test issue.
 	gherkin: String
 	
 	# Cucumber Type definition of the Test Run.
 	scenarioType: String
 	
 	# Comment definition of the Test Run.
 	comment: String
 	
 	# Started On date of the Test Run.
 	startedOn: String
 	
 	# Evidence of the Test Run.
 	evidence: [Evidence]
 	
 	# Defects of the Test Run.
 	defects: [String]
 	
 	# Step definition of the Test Run.
 	steps: [TestRunStep]
 	
 	# Examples of the Test Run.
 	examples: [Example]
 	
 	# Results of the Test Run.
 	results: [Result]
 	
 	# Test Type of the Test Run.
 	testType: TestType
 	
 	# User's account id that executed the Test Run.
 	executedById: String
 	
 	# User's account id assigned to the Test Run. This is user assigned to the Test Run, not taking into account the assignee of the test execution.
 	assigneeId: String
 	
 	# Finished On date of the Test Run.
 	finishedOn: String
 	
 	# Preconditions of the Test Run.
 	#
 	# Arguments
 	# limit: the maximum amount of Preconditions to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	preconditions(limit: Int!, start: Int): TestRunPreconditionResults
 	
 	# Test of the Test Run.
 	test: Test
 	
 	# Test Execution of the Test Run.
 	testExecution: TestExecution
 	
 	# Date when the test run was last modified.
 	lastModified: String
 	
 	# Custom Fields of the Test Run.
 	customFields: [TestRunCustomFieldValue]
 	
 	# Parameters of the Test Run.
 	parameters: [TestRunParameter]
 	
 	# Iterations of the Test Run.
 	#
 	# Arguments
 	# limit: the maximum amount of iterations to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	iterations(limit: Int!, start: Int): TestRunIterationResults
 	
 	}

	type TestRunCustomFieldValue {
 	
 	id: String
 	
 	name: String
 	
 	values: JSON
 	
 	}

type TestRunCustomStepField {
 	
 	# Id of the Custom Field.
 	id: String
 	
 	# Name of the Custom Field.
 	name: String
 	
 	# Value of the Custom Field.
 	value: JSON
 	
 	}

type TestRunIteration {
 	
 	# Rank of the iteration.
 	rank: String
 	
 	# Parameters of the iteration.
 	parameters: [TestRunParameter]
 	
 	# Status of the iteration.
 	status: StepStatus
 	
 	# Step results of the iteration.
 	#
 	# Arguments
 	# limit: the maximum amount of step results to be returned. The maximum is 100.
 	# start: the index of the first item to return in the page of results (page offset).
 	stepResults(limit: Int!, start: Int): TestRunIterationStepResults
 	
 	}

	type TestRunIterationResults {
 	
 	# Total amount of iterations.
 	total: Int
 	
 	# Index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# Maximum amount of iterations to be returned. The maximum is 100.
 	limit: Int
 	
 	# Iteration results.
 	results: [TestRunIteration]
 	
 	}

type TestRunIterationStepResult {
 	
 	# Id of the Test Run step.
 	id: String
 	
 	# Status of the Test Run step.
 	status: StepStatus
 	
 	# Comment of the Test Run step.
 	comment: String
 	
 	# Evidence of the Test Run step.
 	evidence: [Evidence]
 	
 	# Defects of the Test Run step.
 	defects: [String]
 	
 	# Actual Result of the Test Run step.
 	actualResult: String
 	
 	}

type TestRunIterationStepResults {
 	
 	# Total amount of steps.
 	total: Int
 	
 	# Index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# Maximum amount of step results to be returned. The maximum is 100.
 	limit: Int
 	
 	# Step results.
 	results: [TestRunIterationStepResult]
 	
 	}

type TestRunParameter {
 	
 	name: String
 	
 	value: String
 	
 	}

	type TestRunPrecondition {
 	
 	# Precondition of the Test Run.
 	preconditionRef: Precondition
 	
 	# Precondition definition.
 	definition: String
 	
 	}

type TestRunPreconditionResults {
 	
 	# Total amount of preconditions.
 	total: Int
 	
 	# Index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# Maximum amount of Preconditions to be returned. The maximum is 100.
 	limit: Int
 	
 	# Precondition results.
 	results: [TestRunPrecondition]
 	
 	}

	type TestRunResults {
 	
 	# Total amount of Test Runs.
 	total: Int
 	
 	# The index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# The maximum amount of Test Runs to be returned. The maximum is 100.
 	limit: Int
 	
 	# Test Run results.
 	results: [TestRun]
 	
 	}

	type TestRunStep {
 	
 	# Id of the Test Run Step.
 	id: String
 	
 	# Status of the Test Run Step.
 	status: StepStatus
 	
 	# Action of the Test Run Step.
 	action: String
 	
 	# Data of the Test Run Step.
 	data: String
 	
 	# Result of the Test Run Step.
 	result: String
 	
 	# Custom Fields of the Test Run Step.
 	customFields: [TestRunCustomStepField]
 	
 	# Comment of the Test Run Step.
 	comment: String
 	
 	# Evidence of the Test Run Step.
 	evidence: [Evidence]
 	
 	# Attachments of the Test Run Step.
 	attachments: [Attachment]
 	
 	# Defects of the Test Run Step.
 	defects: [String]
 	
 	# Actual Result of the Test Run Step.
 	actualResult: String
 	
 	}

type TestSet {
 	
 	# Issue id of the Test Set Issue.
 	issueId: String
 	
 	# Project id of the Test Set Issue.
 	projectId: String
 	
 	# List of Tests associated with the Test Set Issue.
 	#
 	# Arguments
 	# issueIds: Ids of the Tests.
 	# limit: Maximum amount of tests to be returned. The maximum is 100.
 	# start: Index of the first item to return in the page of results (page offset).
 	tests(issueIds: [String], limit: Int!, start: Int): TestResults
 	
 	# Extra Jira information of the Test Set Issue.
 	#
 	# Arguments
 	# fields: List of the fields to be displayed.
 	# Check the field 'fields' of this Jira endpoint for more information.
 	jira(fields: [String]): JSON
 	
 	# Date when the test set was last modified.
 	lastModified: String
 	
 	}

	type TestSetResults {
 	
 	# Total amount of issues.
 	total: Int
 	
 	# Index of the first item to return in the page of results (page offset).
 	start: Int
 	
 	# Maximum amount of test sets to be returned. The maximum is 100.
 	limit: Int
 	
 	# Test Set issue results.
 	results: [TestSet]
 	
 	}

type TestStatusType {
 	
 	# Name of the Test Status.
 	name: String
 	
 	# Description of the Test Status.
 	description: String
 	
 	# Whether the status is final or not.
 	final: Boolean
 	
 	# Color of the Test Status.
 	color: String
 	
 	}

type TestType {
 	
 	# Id of the Test Type.
 	id: String
 	
 	# Name of the Test Type.
 	name: String
 	
 	# Kind of the Test Type.
 	# Possible values are "Gherkin", "Steps" or "Unstructured".
 	kind: String
 	
 	}

	type UpdateIterationStatusResult {
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

 	type UpdateTestRunExampleStatusResult {
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

 	type UpdateTestRunResult {
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

	type UpdateTestRunStepResult {
 	
 	# Ids of the added Defects.
 	addedDefects: [String]
 	
 	# Ids of the removed Defects.
 	removedDefects: [String]
 	
 	# Ids of the added Evidence.
 	addedEvidence: [String]
 	
 	# Ids of the removed Evidence.
 	removedEvidence: [String]
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

 	type UpdateTestRunStepStatusResult {
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}

	type UpdateTestStepResult {
 	
 	# List of added attachments.
 	addedAttachments: [String]
 	
 	# List of removed attachments.
 	removedAttachments: [String]
 	
 	# Warnings generated during the operation.
 	warnings: [String]
 	
 	}


input AttachmentDataInput {
 	
 	# A valid AttachmentDataInput must have the properties filename, mimeType and data defined.
 	# In alternative, the attachmentId property can be used alone.
 	# If both attachmentId and other properties are defined, attachmentId takes precedence and will be used as if it was defined alone.
 	#
 	#
 	# Filename of the attachment.
 	filename: String
 	
 	# Content Type of the attachment.
 	mimeType: String
 	
 	# Data of the attachment. Base64 format.
 	data: String
 	
 	# Id of an attachment.
 	attachmentId: String
 	}

input AttachmentInput {
 	
 	# Filename of the attachment.
 	filename: String
 	
 	# Content Type of the attachment.
 	mimeType: String
 	
 	# Data of the attachment. This data should be in base64.
 	data: String
 	}

 	input AttachmentOperationsInput {
 	
 	# Attachments to add to the Step.
 	add: [AttachmentInput]
 	
 	# Ids of the attachments to remove from the Step.
 	removeIds: [String]
 	
 	# Filenames of the attachments to remove from the Step.
 	removeFilenames: [String]
 	}

	input CreateStepInput {
 	
 	# Action of the Step.
 	action: String
 	
 	# Data of the Step.
 	data: String
 	
 	# Result of the Step.
 	result: String
 	
 	# Attachments of the Step.
 	attachments: [AttachmentInput]
 	
 	# Custom Fields of the Step
 	customFields: [CustomStepFieldInput]
 	
 	# The issue id of the test called by the step.
 	callTestIssueId: String
 	}

	input CustomFieldInput {
 	
 	# Id of the custom field.
 	id: String
 	
 	# Value of the custom field.
 	value: JSON
 	}

	input CustomStepFieldInput {
 	
 	# Id of the Custom Field.
 	id: String
 	
 	# value of the Custom Field.
 	value: JSON
 	}

input FolderSearchInput {
 	
 	# Path of the Folder.
 	path: String!
 	
 	# Test Plan id of the Folder.
 	testPlanId: String
 	
 	# Whether descendant folders should be included in the search.
 	includeDescendants: Boolean
 	}

	input PreconditionFolderSearchInput {
 	
 	# Path of the Folder.
 	path: String!
 	
 	# Whether descendant folders should be included in the search.
 	includeDescendants: Boolean
 	}

input TestRunDefectOperationsInput {
 	
 	# Defects to add to the Test Run Step.
 	add: [String]
 	
 	# Defects to remove from the Test Run Step.
 	remove: [String]
 	}

input TestRunEvidenceOperationsInput {
 	
 	# Evidence to add to the Test Run Step.
 	add: [AttachmentDataInput]
 	
 	# Evidence ids to remove from the Test Run Step.
 	removeIds: [String]
 	
 	# Evidence filenames to remove from the Test Run Step.
 	removeFilenames: [String]
 	}

input TestTypeInput {
 	
 	# Id of the Test Type.
 	id: String
 	
 	# Name of the Test Type.
 	name: String
 	
 	# Kind of the Test Type.
 	# Possible values are "Gherkin", "Steps" or "Unstructured".
 	kind: String
 	}

	input UpdatePreconditionInput {
 	
 	# Precondition type of the Precondition Issue.
 	preconditionType: UpdatePreconditionTypeInput
 	
 	# Definition of the Precondition Issue.
 	definition: String
 	
 	# the repository path to which the Precondition should be moved to
 	folderPath: String
 	}

input UpdatePreconditionTypeInput {
 	
 	# Id of the Precondition Type.
 	id: String
 	
 	# Name of the Precondition Type.
 	name: String
 	}

input UpdateStepInput {
 	
 	# Action of the Step.
 	action: String
 	
 	# Data of the Step.
 	data: String
 	
 	# Result of the Step.
 	result: String
 	
 	# Attachments of the Step.
 	attachments: AttachmentOperationsInput
 	
 	# Custom Fields of the Step
 	customFields: [CustomStepFieldInput]
 	}

input UpdateTestRunStepInput {
 	
 	# Comment to add to the Test Run Step.
 	comment: String
 	
 	# Status to set to the Test Run Step.
 	status: String
 	
 	# Evidence of the Test Run Step.
 	evidence: TestRunEvidenceOperationsInput
 	
 	# Defects of the Test Run Step.
 	defects: TestRunDefectOperationsInput
 	
 	# Actual Result of the Test Run Step.
 	actualResult: String
 	}

	input UpdateTestTypeInput {
 	
 	# Id of the Test Type.
 	id: String
 	
 	# Name of the Test Type.
 	name: String
 	}

scalar Boolean
scalar Float
scalar Int
scalar JSON
scalar String